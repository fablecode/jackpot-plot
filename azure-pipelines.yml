# Jackpot CI (Linux): GitVersion (CLI) + Build + Tests + Coverage + Publishing

trigger:
  - main

variables:
  DOTNET_SDK: '8.0.x'
  BUILD_CONFIGURATION: 'Release'
  SOLUTION: 'JackpotPlot.sln'
  SRC_PROJECTS: '**/*.csproj'
  TEST_PROJECTS: '**/*Tests.csproj'
  COVERAGE_THRESHOLD: '1' # fail build if total line coverage < threshold
  COVERAGE_EXCLUDE_GLOBS: '["**/bin/**","**/obj/**","**/*Migrations*/*"]'
  # Use a stable, cached NuGet folder across jobs
  NUGET_PACKAGES: '$(Pipeline.Workspace)/.nuget/packages'

pool:
  vmImage: 'ubuntu-latest'

steps:
  - checkout: self
    fetchDepth: 0
    displayName: 'Checkout Source Code'

  # Ensure .NET SDK (do this BEFORE GitVersion CLI)
  - task: UseDotNet@2
    displayName: 'Use .NET SDK $(DOTNET_SDK)'
    inputs:
      packageType: sdk
      version: '$(DOTNET_SDK)'

  # ---------------- GitVersion via CLI (no marketplace task needed) ----------------
  - bash: |
      git fetch --force --tags --prune
      dotnet tool install -g GitVersion.Tool --version 6.*
      export PATH="$PATH:$HOME/.dotnet/tools"
      dotnet-gitversion /output buildserver /config GitVersion.yml /verbosity minimal
    displayName: 'Fetch tags + GitVersion'

  - bash: |
      set -euo pipefail
      export PATH="$PATH:$HOME/.dotnet/tools"

      # ensure a helper that sets a var if it's empty/missing
      set_var () {
        local name="$1"
        local val="$(printenv "$name" || true)"
        if [ -z "$val" ]; then
          val="$(dotnet-gitversion /showvariable "${name#GitVersion.}" /config GitVersion.yml || true)"
          echo "##vso[task.setvariable variable=$name]$val"
        fi
        echo "$name=$val"
      }

      # seed any that were missing
      set_var "GitVersion.NuGetVersionV2"
      set_var "GitVersion.NuGetVersion"
    displayName: 'Backfill missing GitVersion vars'


  - bash: |
      echo "SemVer: $(GitVersion.SemVer)"
      echo "FullSemVer: $(GitVersion.FullSemVer)"
      echo "Major: $(GitVersion.Major)"
      echo "Minor: $(GitVersion.Minor)"
      echo "Patch: $(GitVersion.Patch)"
      echo "PreReleaseTag: $(GitVersion.PreReleaseTag)"
      echo "InformationalVersion: $(GitVersion.InformationalVersion)"
      echo "AssemblySemVer: $(GitVersion.AssemblySemVer)"
      echo "AssemblySemFileVer: $(GitVersion.AssemblySemFileVer)"
      echo "NuGetVersionV2: $(GitVersion.NuGetVersionV2)"
      echo "NuGetVersion: $(GitVersion.NuGetVersion)"
      echo "MajorMinorPatch: $(GitVersion.MajorMinorPatch)"
    displayName: 'Output GitVersion variables'


  # Set run number to the computed SemVer
  - bash: echo "##vso[build.updatebuildnumber]$(GitVersion.SemVer)"
    displayName: 'Set build number from GitVersion'


  # ---------------- Restore & quality checks ----------------
  - script: dotnet restore "$(SOLUTION)"
    displayName: 'dotnet restore'

  # Optional: verify code style (fail if formatting required). Excludes tests if you want.
  - bash: |
      dotnet tool install -g dotnet-format
      export PATH="$PATH:$HOME/.dotnet/tools"

      # 1) Auto-fix formatting (no --verify flag)
      dotnet format --verbosity minimal

      # 2) If anything changed, publish a patch file for devs to apply
      git diff > format-fixes.patch || true
      if [ -s format-fixes.patch ]; then
        echo "Formatting changes detected; publishing format-fixes.patch"
      else
        echo "No formatting changes."
      fi
    displayName: 'Auto-fix code style (dotnet format)'
    continueOnError: true  # do not fail the build even if format found issues

  - task: PublishPipelineArtifact@1
    displayName: 'Publish formatting patch'
    condition: always()
    inputs:
      targetPath: 'format-fixes.patch'
      artifact: 'format-fixes'

  # ---------------- Build (warnings as errors) ----------------
  - script: >
      dotnet build "$(SOLUTION)"
      -c $(BUILD_CONFIGURATION)
      --no-restore
      /p:TreatWarningsAsErrors=false
      /p:ContinuousIntegrationBuild=true
      /p:Version=$(GitVersion.SemVer)
      /p:AssemblyVersion=$(GitVersion.AssemblySemVer)
      /p:FileVersion=$(GitVersion.AssemblySemFileVer)
      /p:InformationalVersion=$(GitVersion.InformationalVersion)
    displayName: 'dotnet build (with GitVersion)'


  # ---------------- Test + Coverage (gate) ----------------
  - bash: |
      set -euo pipefail

      if ! command -v jq >/dev/null 2>&1; then
        sudo apt-get update -y
        sudo apt-get install -y jq
      fi

      OUT_ROOT="$(Build.SourcesDirectory)/TestResults"
      COV_ROOT="$OUT_ROOT/Coverage"
      mkdir -p "$OUT_ROOT" "$COV_ROOT"

      EXCLUDE_ARG=""
      if [ -n "$(COVERAGE_EXCLUDE_GLOBS)" ]; then
        EXCL=$(echo '$(COVERAGE_EXCLUDE_GLOBS)' | jq -r 'join(";")')
        [ -n "$EXCL" ] && EXCLUDE_ARG="/p:ExcludeByFile=\"$EXCL\""
      fi

      dotnet test "$(SOLUTION)" \
        -c '$(BUILD_CONFIGURATION)' \
        --no-build \
        --logger "trx;LogFileName=test_results.trx" \
        --blame-hang --blame-hang-timeout 5m \
        --results-directory "$OUT_ROOT" \
        /p:CollectCoverage=true \
        /p:CoverletOutputFormat=cobertura \
        /p:CoverletOutput="$COV_ROOT/\$\(MSBuildProjectName\)/" \
        /p:SkipAutoProps=true \
        /p:Threshold=$(COVERAGE_THRESHOLD) \
        /p:ThresholdType=line \
        /p:ThresholdStat=total \
        $EXCLUDE_ARG
    displayName: 'dotnet test + coverage (with gate)'


  # Publish TRX to test tab
  - task: PublishTestResults@2
    displayName: 'Publish Test Results'
    inputs:
      testResultsFormat: VSTest
      testResultsFiles: '$(Build.SourcesDirectory)/TestResults/**/*.trx'
      mergeTestResults: true
      testRunTitle: 'Unit Tests'

  # ---------------- Coverage report (merge + publish) ----------------
  - script: dotnet tool install -g dotnet-reportgenerator-globaltool
    displayName: 'Install ReportGenerator'

  - bash: |
      echo "##vso[task.prependpath]$HOME/.dotnet/tools"
      REPORTS_GLOB='$(Build.SourcesDirectory)/TestResults/Coverage/**/coverage.cobertura.xml'
      REPORT_OUT='$(Build.SourcesDirectory)/TestResults/Coverage/Report'
      mkdir -p "$REPORT_OUT"
      reportgenerator -reports:"$REPORTS_GLOB" -targetdir:"$REPORT_OUT" -reporttypes:'HtmlInline_AzurePipelines;Cobertura'
    displayName: 'Generate merged coverage report'

  - task: PublishCodeCoverageResults@2
    displayName: 'Publish Code Coverage'
    inputs:
      summaryFileLocation: '$(Build.SourcesDirectory)/TestResults/Coverage/Report/Cobertura.xml'
      # If needed for non-absolute paths (e.g., some JaCoCo reports), uncomment:
      # pathToSources: '$(Build.SourcesDirectory)'
      failIfCoverageEmpty: true


  # ---------------- CI summary ----------------
  - bash: |
      cat > $(Build.SourcesDirectory)/ci-summary.md <<'EOF'
      # CI Summary

      **Version:** $(GitVersion_SemVer)  
      **Branch:** $(Build.SourceBranchName)  
      **Commit:** $(Build.SourceVersion)

      - Build configuration: $(BUILD_CONFIGURATION)
      - Coverage threshold: $(COVERAGE_THRESHOLD)%
      - SDK: $(DOTNET_SDK)

      **Artifacts**
      - Coverage HTML: _Artifacts_ → `coverage-report`
      - TRX & raw coverage: _Artifacts_ → `test-assets`
      EOF
      echo "##vso[task.uploadsummary]$(Build.SourcesDirectory)/ci-summary.md"
    displayName: 'Publish CI summary'

  # ---------------- Artifacts ----------------
  - task: PublishPipelineArtifact@1
    displayName: 'Publish coverage HTML artifact'
    inputs:
      targetPath: '$(Build.SourcesDirectory)/TestResults/Coverage/Report'
      artifact: 'coverage-report'

  - task: PublishPipelineArtifact@1
    displayName: 'Publish raw test assets (trx, cobertura)'
    inputs:
      targetPath: '$(Build.SourcesDirectory)/TestResults'
      artifact: 'test-assets'
